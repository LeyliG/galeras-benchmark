# Benchmarking Causal Analysis for Interpreting LLMs for Source Code

This project strives to create a benchmark to create causal analysis for LLM SE tasks. It does this by ustilizing the Galeras raw dataset for various different SE tasks and analyizing the results. This highlights the use cases of Galeras and its analysis approach.

## Use Cases

The primary focus is on answering causal queries of interest related to LLMs. It enables ML researchers in software engineering to explain the causal effect of a set of confounders associated with the treatment input prompt. Some of the use cases include:

### Code Auto-Completion:
Galeras can be used to evaluate LLM's performance in auto-completing code. Its provided non-contaminated code snippets can be used with our random cut implementation to randomly cut the code snippet somewhere after the code signature.

### Code Summarization:
Additionally, this facilitates the examination of an LLM's capacity for code summarization. Researchers can investigate the influence of various confounders on the production of code summaries by leveraging the dataset and benchmark provided.
### Code Generation
ML researchers have the opportunity to evaluate LLM's proficiency in producing test cases using Galeras. The benchmark provides a dedicated dataset tailored for test generation purposes, enabling a comprehensive assessment and interpretation of code generation performance.

### Bug Fixing:
we can be utilize this to analyze LLM's effectiveness in bug fixing. Researchers can evaluate the causal relationship between different confounders and the accuracy of bug fixes generated by LLMs.

### Testbed Generation and Curation:

The collection pipeline for this dataset is as follows:

![Collection Pipeline](./figures/approach/galeras-pipeline.png)

In the first step, popular github repos are filtered using the following query: 
*language : Python, fork : false, size :>= 30, 000,
pushed :> 2021 - 12 - 31, stars :> 1, 000*

Given ChatGPT's and the other LLMc under analysis have a training data cutoff date of ~September 2021, we selected data from January 2, 2022 to January 1, 2023. Therefore, we make the claim that our testbeds help to avoid *data snooping*. 

We then extracted code and documentation related features from each data point. After, using the [Tree-Sitter](https://tree-sitter.github.io/tree-sitter/) library, we parsed AST variables from each data point. These resultant features were de-duplicated, which reduced the test bed size to ~227k data points. There were ~77k data points that had a valid *docstring* that is: a docstring that is longer than 3 words. This docstring does not include inline comments.

We then selected 960 data points to manually validate out of the ~227k data points from *RawData* and *RawDataDocstring*. The remaining data points were verified automatically.

Our steps for verification are as follows:
- Verify that the push date of each commit is within the acceptable range (January 2, 2022 to January 1 2023)
- Confirm that the method associated with any given commit was actually changed in the changelog
- Validate *n_words*
- Validate confounders
- Validate AST levels and AST errors using [Tree-Sitter Playground](https://tree-sitter.github.io/tree-sitter/playground)
- Validate cyclomatic compleixty using pycharm
- Verify whitespace count
- Verify if random split is after function signature
- Verify docstring is not empty
- Remove all one line functions and pass statements
- Select functions with more than one return statement
- Confirm that summary is meaningful
- Confirm that summary/docstring accurately represent code snippet functionality

After this verification step, we then sampled 3k data points from *RawData* in order to build five additional testbeds, each for a specific SE task. They are:
- *RandomCut*
- *WithDocString*
- *FromDocString*

for analysis on code completion tasks. As well as:
- *CommitGen*
- *SummarizationGen*

for analysis on code summarization tasks. 

In order to create *RandomCut* data points were selected that contain more than 10 tokens or 100 characters, and the data point is randomly cut after the method signature.

*SummarizationGen* and *CommitGen* are drawn from *RawDataDocstring* that contain more than 10 words or 50 characters. 

![Jaccard Similarity](./figures/use_case/jaccard_similarity.png)

The resultant five datasets were deduplicated based on the Jaccard Similarity of data points computed using BPE HuggingFace tokenizer. This figure lists the SE task that each dataset is suited for, along with the number and percentage of duplicate datapoints, and resultant size after deletion.

![Table](./figures/use_case/descriptive_analysis.png)

This table shows summary statistics about the aformentioned data subsets.

## Analysis Approach

Galeras employs a causal analysis methodology to interpret the code generation process of LLM. It utilizes a combination of control and two prompt treatments to configure the input for the model. The analysis primarily focuses on identifying the causal impact of confounders, which encompass the input code and text description, on both the treatment input prompt and the resulting generated code output.

The goal of galeras is to provide a benchmark to compare the performance of LLMc against each other by controlling for features of the source code that can influence the prediction perforamnce of LLMc, or *confounding variables*. Galeras can be used to contextualize the outcomes of LLMc by providing tailorable treatment variables. 

![SCM Benchmarking](./figures/use_case/Galeras-Model.png)

The end goal of galeras is for the research community to be able to understand typical perforamnce metrics by stating the assumptions of the predicition problem in a *Structured Causal Model* (SCM). In our case, the SCM is comprised of four random variables. *T* - treatments, *Y* - potential outcomes, *Z* - confounders, and *effect modifiers*.

*T* is the input configuration prompts in our case study. *Y* is the model predicition perforamnce, which can be measured in several different ways. (*e.g.* BLUE CodeBLUE Levenshtein). *Z* is variables affecting both *T* and *Y*. Finally, *effect modifiers* are features directly effecting the outcome *Y*. 



The benchmark provides a curated dataset with uncontaminated code snippets, accompanied by various confounding features for each data point.  By examining the causal relationship between these confounding factors and the model's output, researchers can gain valuable insights into the factors that influence code generation in LLM.

## Evaluation

The benchmark underscores the significance of using clean datasets and prioritizes the provision of uncontaminated data for evaluation purposes. ML researchers have the capability to leverage this in generating fresh datasets tailored to specific software engineering tasks. This enables them to evaluate the performance of LLM on pertinent and carefully curated data.

## Conclusion

 By focusing on causal queries and considering a wide range of confounding features, Galeras enables ML researchers in SE to evaluate and interpret the code generation capabilities of LLMs. The benchmark dataset and testbeds facilitate transparent and interpretable evaluations, addressing the limitations of relying solely on accuracy metrics.




[def]: https://github.com/WM-SEMERU/chat-gpt-failures/blob/update_readme/figures/approach/galeras-pipeline.pdf